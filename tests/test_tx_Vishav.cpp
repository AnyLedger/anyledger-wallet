/**
* @brief 
* @file test_tx.cpp
* @author J.H. 
* @date 2018-10-11
* @edited by Vishav
* @date 2018-10-20
*/

/* module header */

/* system includes C */

/* system includes C++ */
#include <gtest/gtest.h>
#include <fstream>
#include<iostream>
#include<stdlib.h>
//#include<Python.h>
#include <string>
/* local includes */
#include "eth/transaction.h"
#include "eth/sign.h"
#include "helpers/hextobin.h"

using namespace std;

ifstream inFile;



TEST(TEST_TX, TEST_TX_SET)
{
    
    transaction_t tx;
    
    ASSERT_EQ(tx_set_to(&tx,"1234567890abcdef1234567890ABCDEF12345678"),0);
    ASSERT_EQ(tx_set_to(&tx,"1234567890abcdef1234567890ABCDEF123456"),-1);
    ASSERT_EQ(tx_set_to(&tx,"1234567890abcdef1234567890ABCDEF123456xx"),-1);
    ASSERT_EQ(tx_set_to(&tx,"xx"),-1);
    ASSERT_EQ(tx_set_to(&tx,""),-1);
}

/* 
The Encode Test verifies the unsigned tx data generated by the python script unsigned_tx.py
Before running this test it is recommended to run the python script. The Python script will generate the unsigned data 
and store it in data.txt file. This data would be read by this test to verify the data 
*/
TEST(TEST_TX, TEST_TX_ENCODE)
{
    ifstream unsigned_tx_data; //if stream object
    /*update the location to anyledger-wallet/tests*/
    unsigned_tx_data.open("/home/vishav/anyledger-wallet/tests/data.txt"); //data.txt is file generated by python
    /*Verify if file is present*/
    if (unsigned_tx_data.fail())
    {
        cerr<<"error opening data.txt File"<<endl<<"Please update the path of the file in above lines"<<endl;
        exit(1);
    }
    
    char data[60]; //string for reading the data from data.txt
    memset(data,0,60); //setting all values to 0
    unsigned_tx_data >> data;//first line read from data.txt
    
    char *data_no_0x = strtok(data,"x");//data variable without 0x
    data_no_0x=strtok(NULL,"x");// string without 0x
    uint8_t byte_length[(strlen(data_no_0x))/2];//byte array declaration
    hextobin(data_no_0x,byte_length,sizeof(byte_length));//converting hex string to byte array
    
    transaction_t tx;
    const uint32_t ENCODED_TX_BUFSIZE = 100;
    uint8_t buf[ENCODED_TX_BUFSIZE] = {0};

    /*setting transaction parameter values as python script*/
    tx.nonce = 1;
    tx.gas_price = 1;
    tx.gas_limit = 300;
    tx_set_to(&tx, "7e5f4552091a69125d5dfcb7b8c2659029395bdf");
    tx_set_value_u64(&tx, 1);
    tx.data = NULL;
    tx.data_len = 0;

    /*Encoding unsigned transaction*/
    uint32_t data_len = tx_encode(&tx, NULL, buf, ENCODED_TX_BUFSIZE);

    for (int i = 0; i < data_len; i++) {
        printf("%02x", buf[i]);
    }
    
    /*Asserting if the value of each byte array matches*/
    for(int i =0; i<sizeof(byte_length);i++)
    {
        ASSERT_EQ(byte_length[i],buf[i]);
    }    
    
}
#if 0
TEST(TEST_TX, TEST_TX_ENCODE_AND_SIGN)
{
    transaction_t tx;
    const uint32_t ENCODED_TX_BUFSIZE = 100;
    uint8_t buf[ENCODED_TX_BUFSIZE] = {0};
	uint8_t priv[32];
    hextobin("0000000000000000000000000000000000000000000000000000000000000001", priv, sizeof(priv));

    tx.nonce = 1998;
    tx.gas_price = 1 * 1000000000;
    tx.gas_limit = 21612;
//    tx_set_to(&tx, "7e5f4552091a69125d5dfcb7b8c2659029395bdf");
    tx_set_to(&tx, "2e83b5ae698e1f1ab5b6f4bb0732d72f0c74d049");
    tx_set_value_u64(&tx, 0);
    tx.data = (uint8_t*)"anyledger";
    tx.data_len = strlen((const char*)tx.data);

    uint32_t data_len = tx_encode(&tx, NULL, buf, ENCODED_TX_BUFSIZE);

    for (size_t i = 0; i < data_len; i++) {
        printf("%02x", buf[i]);
    }
    printf("\n");

    signature_t tx_sig;

    eth_sign_data(priv, (uint8_t*)buf, data_len, &tx_sig);
    for (size_t i = 0; i < (sizeof(uint256_t)*2); i++) {
        printf("%02x", ((uint8_t*)&tx_sig)[i]);
    }
    printf("%02x", tx_sig.v);
    printf("\n");

    data_len = tx_encode(&tx, &tx_sig, buf, ENCODED_TX_BUFSIZE);
    for (size_t i = 0; i < data_len; i++) {
        printf("%02x", buf[i]);
    }
    printf("\n");

}
#endif
